function BacktrackProperties = Generate_BacktrackProperties()% Load a Results file (or multiple results files corresponding to the same% conditions) with StepSize data from StepFinding and calculate various% properties of backtracks. It is very similar to the function that% generates StepSize/DwellTime%% USE: BacktrackProperties = Generate_BacktrackProperties()%% Gheorghe Chistol, 23 Feb 2011%% Ask for the ParametersPrompt = {'Step Size Histogram Bin Size (bp)',...          'Substrate DNA Contour (bp)',...          'Display Results: Filling Bin Size (bp)',...          'Display Results: Lower Limit Filling (bp)',...          'Display Results: Upper Limit Filling (bp)',...          'StepMerging: Max Allowed Small Step (bp)',...          'StepMerging: Max Allowed Burst Size (bp)',...          'StepMerging: Max Allowed Dwell Between Added Steps (sec)',...          'CutoffAnalysis: Min Allowed Burst Size (bp)'};Title = 'Enter the Following Parameters';Lines = 1;Default = {'0.5','21000','1000','17000','20000','9','11','.1','8.5'};Options.Resize='on'; Options.WindowStyle='normal'; Options.Interpreter='tex';Answer = inputdlg(Prompt, Title, Lines, Default, Options);StepSizeBinSize        = str2num(Answer{1}); %#ok<*ST2NM>SubstrateContour       = str2num(Answer{2});ResultBinning          = str2num(Answer{3});LowerLimitFilling      = str2num(Answer{4});UpperLimitFilling      = str2num(Answer{5});MaxSmallStep           = str2num(Answer{6});MaxAllowedBurst        = str2num(Answer{7});MaxAllowedDwellBetween = str2num(Answer{8});MinAllowedBurst        = str2num(Answer{9}); %in bp%% Global Variables and select the folder where Step/Dwell Data is storedglobal analysisPath;if isempty(analysisPath)   disp('analysisPath not defined. Use "SetAnalysisPath" to define it'); return;end%Select one or more MAT results files from StepFinding that correspond to%the same conditions (ATP, substrate)[DataFile DataPath] = uigetfile([ [analysisPath filesep ] '*.mat'], 'Please select one or more Results files','MultiSelect', 'on');if isempty(DataFile) %if no files were selected    disp('No *.mat phage files were selected');return;endif ~iscell(DataFile) %if there is only one file, make it into a cell, for easier processing later    temp=DataFile; clear DataFile; DataFile{1}=temp;endFillingIntervals=LowerLimitFilling:ResultBinning:UpperLimitFilling;for fr=1:length(FillingIntervals)-1;    BacktrackProperties(fr).MinFilling        = FillingIntervals(fr); %lower limit of the Filling Range    BacktrackProperties(fr).MaxFilling        = FillingIntervals(fr+1); %#ok<*AGROW> %upper limit of the Filling Range    BacktrackProperties(fr).AmountDnaPackaged = 0; %Amount of DNA packaged for the data that went into this bin    BacktrackProperties(fr).DwellBefore       = []; %the DwellTime before the back-step    BacktrackProperties(fr).DwellAfter        = []; %the DwellTime after the back-step    BacktrackProperties(fr).BackStepSize      = []; %the size of the back-step    BacktrackProperties(fr).NextStepSize      = []; %the size of the next step after the back-step    %BacktrackProperties(fr).Filling           = []; %filling that corresponds to that particular back-step endfor DF=1:length(DataFile) %DF is the index for DataFile    load([DataPath filesep DataFile{DF}]); %data is stored in the data structure FinalDwells    disp(['Loaded File ' DataFile{DF}]);    %FinalDwells{FileIndex}{FeedbackCycleIndex}        for fr=1:length(BacktrackProperties)        CurrMinFill = BacktrackProperties(fr).MinFilling; %current MinFilling        CurrMaxFill = BacktrackProperties(fr).MaxFilling; %current MaxFilling                for FileIndex=1:length(FinalDwells) %#ok<*USENS> %go through all traces in FinalDwells           for FeedbackCycleIndex=1:length(FinalDwells{FileIndex}) %go through all feedback cycles for each trace               if ~isempty(FinalDwells{FileIndex}{FeedbackCycleIndex}) %make sure it's not empty, sometimes it happens                    CurrFeedbackCycleFill = SubstrateContour-mean(FinalDwells{FileIndex}{FeedbackCycleIndex}.DwellLocation);                    if CurrFeedbackCycleFill<CurrMaxFill && CurrFeedbackCycleFill>CurrMinFill %if the current feedback cycle falls within the current FillingRange/Bin                        tempStepSize=-FinalDwells{FileIndex}{FeedbackCycleIndex}.StepSize; %the minus sign makes normal steps positive and backsteps negative                        tempDwellTime = FinalDwells{FileIndex}{FeedbackCycleIndex}.DwellTime; %the dwelltimes for this feedback trace                        BacktrackProperties(fr).AmountDnaPackaged = BacktrackProperties(fr).AmountDnaPackaged+sum(tempStepSize);                                                for s=1:length(tempStepSize)-1 %we want to know the step-size after the back-step, thus the "1:length(tempStepSize)-1" range                            if tempStepSize(s)<0                                BacktrackProperties(fr).DwellBefore(end+1)  = tempDwellTime(s);                                BacktrackProperties(fr).DwellAfter(end+1)   = tempDwellTime(s+1);                                BacktrackProperties(fr).BackStepSize(end+1) = tempStepSize(s);                                BacktrackProperties(fr).NextStepSize(end+1) = tempStepSize(s+1);                                %BacktrackProperties(fr).Filling(end+1)      = CurrFeedbackCycleFill;                            end                        end                    end               end           end        end    endend%% Go through each Filling Range and plot its contentsfor fr=1:length(BacktrackProperties)    %define the min and the max for the current situation    CurrMaxFill = BacktrackProperties(fr).MaxFilling;     CurrMinFill = BacktrackProperties(fr).MinFilling;        if ~isempty(BacktrackProperties(fr).BackStepSize)        %there is stuff to plot, so go ahead        figure('Units','normalized','Position',[0.0256    0.2178    0.2687    0.5544]);         subplot(2,1,1);        x=BacktrackProperties(fr).BackStepSize;        Keepers=x<20&x>-20;        x=x(Keepers);        y=BacktrackProperties(fr).NextStepSize;        y=y(Keepers);        z=x+y; %sum of the two steps        z=z(z>-20 & z<20);        [Fb Xb]=ksdensity(x);        [Fs Xs]=ksdensity(z);        plot(Xb,Fb,'b',Xs,Fs,'k');        legend('BackStep','BackStep+NextStep','Location','ne')        xlabel('Size (bp)');        ylabel('Norm Probability Density ')        set(gca,'XLim',[-15 20]);        title(['Capsid Filling:' num2str(CurrMinFill) '-' num2str(CurrMaxFill) 'bp']);        %         TimeBinSize=0.05;%         subplot(2,2,2);%         temp=BacktrackProperties(fr).DwellBefore;%         Bins=0+TimeBinSize/2:TimeBinSize:max(temp)+TimeBinSize/2;%         hist(temp,Bins);        %         xlabel('Dwell Time Before Back Step (sec)');%         %set(gca,'XScale','log');%         %         subplot(2,2,4);%         %x=BacktrackProperties(fr).BackStepSize;%         temp=BacktrackProperties(fr).DwellAfter;%         Bins=0+TimeBinSize/2:TimeBinSize:max(temp)+TimeBinSize/2;%         hist(temp,Bins);%         xlabel('Dwell Time After Back Step (bp)');%         %set(gca,'XScale','log');                subplot(2,1,2);        x=BacktrackProperties(fr).DwellBefore;        y=BacktrackProperties(fr).DwellAfter;        plot(x,y,'.b');        xlabel('Dwell Time Before (sec)');        ylabel('Dwell Time After (sec)');        set(gca,'XScale','log');        set(gca,'YScale','log');        title(['Capsid Filling:' num2str(CurrMinFill) '-' num2str(CurrMaxFill) 'bp']);    endend
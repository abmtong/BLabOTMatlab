function [Data LongDwellData] = StepFinding_ComputePropertiesOfLongPauses()% Calculate the frequency of long pauses (how many pauses per kb packaged)% Calculate the duration of long pauses (how many seconds per kb packaged)%% Each structure contains a series of fields, for example:% StepData(3) =%%           ATP: 200%      BinStart: [1x12 double]%        BinEnd: [1x12 double]%     DwellTime: {1x12 cell}% DwellLocation: {1x12 cell}%      StepSize: {1x12 cell}%  StepLocation: {1x12 cell}%% USE: [Data LongDwellData] = StepFinding_ComputePropertiesOfLongPauses()% Gheorghe Chistol, 01 Nov 2010%% Ask for the ParametersPrompt = {'Length of Packaged DNA(bp)',...          'DNA Length Bin Start (bp)',...          'DNA Length Bin End (bp)',...          'DNA Length Bin Width (bp)',...          'Long Dwell Lower Limit (sec)'};  Title = 'Enter the Following Parameters';Lines = 1;Default = {'21000','17000','21000','500','2'};Options.Resize='on'; Options.WindowStyle='normal'; Options.Interpreter='tex';Answer = inputdlg(Prompt, Title, Lines, Default, Options);%Hist parameters refer to the histogram display at the endLengthDNA           = str2num(Answer{1}); %the length of packaged DNABinStart            = str2num(Answer{2});BinEnd              = str2num(Answer{3});BinWidth            = str2num(Answer{4});LongDwellLowerLimit = str2num(Answer{5});%% Ask the user to locate the StepFindingResults folderglobal analysisPath;if isempty(analysisPath)     disp('analysisPath not defined. Use "SetAnalysisPath" to define it');    return;elseif analysisPath==0    disp('analysisPath not defined. Use "SetAnalysisPath" to define it');    return;endResultsFolder = uigetdir(analysisPath , 'Select the Folder with Step Finding results');%% Get a list of all sub-folders in the ResultsFolder% index only the ones that are names 100uM, 250uM etc. These contain data at% that particular ATP concentration.ConcListATP   = []; %this is the list of available ATP concentrationsFolderListATP = {}; %this is the list of folders containing dwell/step data for a given [ATP]ItemList = dir(ResultsFolder); %get the list of all files and foldersfor i = 1:length(ItemList)    ItemName = ItemList(i).name;    ItemType = ItemList(i).isdir; %'1' for directories, '0' for files and others    if ItemType==1        %this is a directory        if length(ItemName)>2 && strcmp(ItemName(end-1:end),'uM') %check if the last two characters are uM            %disp(ItemName);            %this is most likely a valid folder for an ATP concentration            temp = ItemName(1:end-2); %this is supposed the be the value of the ATP concentration            temp = str2num(temp); %convert string to a number                        if temp>0                ConcListATP(end+1)   = temp; %in uM                FolderListATP{end+1} = ItemName;            end        end    endendif isempty(FolderListATP)    %no valid ATP folders were identified, quitting    disp('Failed to find any valid ATP data folders !');    disp('... Valid ATP folder names are 100uM or 25uM. Check your naming convention.')    return;end%sort the ATP concentration in ascending order and sort the folders%correspondingly. List all the folders to the user and proceed to loading and%organizing data[ConcListATP SortIndex] = sort(ConcListATP);FolderListATP           = FolderListATP(SortIndex);disp('This is the list of valid ATP data folders found:');for i=1:length(FolderListATP);     disp(FolderListATP{i}); end%% Go into each ATP folder, load all the files and organize the Data accordingly% All *.mat files will be loaded. Valid step/dwell data is organized in a data% structure called "FinalDwells".%for f=1:length(FolderListATP) %index "f" stands for "folder"    CurrentFolder = [ResultsFolder '\' FolderListATP{f}]; %need the full path    temp = what(CurrentFolder);    if ~isempty(temp)        MatFiles = temp.mat; %the list of *.mat files in this folder        if ~isempty(MatFiles) %load the data if there are any mat files, skip this folder otherwise            %we are using a temporary data pool that will be binned later            %DataPool is the name of said structure            Data(f).ATP                   = ConcListATP(f); %this is the ATP concentration for the CurrentFolder            Data(f).PackagedDNA           = [];            Data(f).LongDwellTime         = [];            Data(f).LongDwellLocation     = [];                        for m=1:length(MatFiles)                CurrentFile = MatFiles{m};                clear FinalDwells; %this is the data structure in whichthe step/dwell data is saved                                   %here we're cleaning out the old data structure                                   %in preparation for the new one                load ([CurrentFolder '\' CurrentFile]);                disp(['... Loaded file: ' CurrentFolder '\' CurrentFile]);                                %we need to see if the "FinalDwells" data structure exists                WorkspaceItems = whos; %get all the items in the workspace                FinalDwells_Exist=0; %no FinalDwells cell found                for w=1:length(WorkspaceItems)                    if strcmp(WorkspaceItems(w).name,'FinalDwells') && strcmp(WorkspaceItems(w).class,'cell')                        FinalDwells_Exist=1; %such a cell exists, we're good to go further                    end                end                                if FinalDwells_Exist                    %we have the neccessary data, add it to the pool of already                    %available data, sort it later                    %FinalDwells{PhageIndex}{FeedbackCycle}                    for p=1:length(FinalDwells) %go through all the phages in the FinalDwells                        for fc=1:length(FinalDwells{p}) %go through all the feedback cycles for this particular phage                            if ~isempty(FinalDwells{p}{fc})  %only work with it if any steps were found                                if ~isempty(FinalDwells{p}{fc}.DwellTime)                                     %index d refers to "dwell" we are looking                                    %only at dwells longer than                                    %LongDwellLowerLimit and calculating how far                                    %away long dwells are (in time and space)                                    LongDwellIndex = find(FinalDwells{p}{fc}.DwellTime > LongDwellLowerLimit);                                    %Data Organization:                                    %Data(f).ATP                                                       %Data(f).PackagedDNA                                    %Data(f).LongDwellLocation                                         %Data(f).LongDwellTime                                         LongDwellTime     = FinalDwells{p}{fc}.DwellTime(LongDwellIndex);                                    LongDwellLocation = FinalDwells{p}{fc}.DwellLocation(LongDwellIndex);                                     PackagedDNA       = zeros(1,length(LongDwellIndex)); %set it to zero for now, update it later                                    %now we need to calculate the amount of                                    %packaged DNA corresponding to the                                     for LD=1:length(LongDwellIndex) %LD is the index for "LongDwells"                                        if LD==1 %this is the first long dwell                                            %PackagedDNA corresponding to this long dwell is the                                            %distance from the very first dwell in this feedback                                            %cycle to the location of the current long dwell                                             %disp('FirstLongPause')                                            PackagedDNA(LD) = PackagedDNA(LD)+FinalDwells{p}{fc}.DwellLocation(1)-LongDwellLocation(LD);                                        end                                        if LD==length(LongDwellIndex) %this is the very last dwell                                            %Packaged DNA corresponding to the last dwell is the                                            %distance from the last long dwell to the very last                                            %dwell of the current feedback cycle                                            %disp('LastLongPause')                                            PackagedDNA(LD) = PackagedDNA(LD)+LongDwellLocation(LD)-FinalDwells{p}{fc}.DwellLocation(end);                                        end                                        if LD~=1 && LD~=length(LongDwellIndex) %neither the first nor the last dwell                                            %Packaged DNA is the distance between the previous long                                            %dwell and the current long dwell                                            %disp('MiddleLongPause')                                            PackagedDNA(LD) = PackagedDNA(LD)+LongDwellLocation(LD-1)-LongDwellLocation(LD);                                        end                                    end                                    LongDwellLocation         = LengthDNA-LongDwellLocation; %this gives the amt of DNA packaged                                    Data(f).LongDwellTime     = [Data(f).LongDwellTime      LongDwellTime];                                    Data(f).LongDwellLocation = [Data(f).LongDwellLocation  LongDwellLocation];                                     Data(f).PackagedDNA       = [Data(f).PackagedDNA        PackagedDNA];                                end                            end                        end                    end                else                    disp([CurrentFolder '\' CurrentFile ' does not contain valid data !']);                end            end        else            disp([CurrentFolder ' does not contain any *.mat files !']);        end    endend%% Initialize the Data structure that organizes the Data in binstemp = BinStart:BinWidth:BinEnd; %make the bins for binning velocity data based on the length of DNA packaged%"LongDwellData" stads for CorrelationData%Data Organization:%Data(f).ATP                   %Data(f).PackagedDNA%Data(f).LongDwellLocation     %Data(f).LongDwellTime     for a=1:length(ConcListATP)    LongDwellData(a).ATP                   = ConcListATP(a);    LongDwellData(a).BinStart              = temp(1:end-1); %starting of each bin    LongDwellData(a).BinEnd                = temp(2:end);   %ending of each bin    LongDwellData(a).PackagedDNA           = []; %measured in bp of packaged DNA    LongDwellData(a).FrequencyOfLongPauses = zeros(1,length(LongDwellData(a).BinStart)); %measured in "long pauses per kb of packaged DNA"    LongDwellData(a).TimeSpentInLongPauses = zeros(1,length(LongDwellData(a).BinStart)); %measured in "seconds spent in long pauses per kb of packaged DNA"    LongDwellData(a).LongDwellTime         = {}; %there will be a cell with data corresponding to each bin    LongDwellData(a).LongDwellLocation     = {}; %there will be a cell with data corresponding to each binendRemoveIndex=[]; %this is the index of ATP concentrations that have no data and need to be removed at the endfor a=1:length(Data); %index a stands to "ATP", refers to various atp concentrations    if ~isempty(Data(a).LongDwellLocation)        BinStart = LongDwellData(a).BinStart;        BinEnd   = LongDwellData(a).BinEnd;                for b=1:length(BinStart) %index b refers to Bins            CurrentBinStart = BinStart(b);            CurrentBinEnd   = BinEnd(b);                        %-------------- Organize Dwell Data separately            IndSmaller = Data(a).LongDwellLocation < CurrentBinEnd; %index of all the points smaller than upper limit            IndLarger  = Data(a).LongDwellLocation > CurrentBinStart; %index of all the points largert than lower limit             IndexKeep  = logical(IndLarger.*IndSmaller); %the index of the dwells that belong to the current bin            IndexKeep  = find(IndexKeep==1);            %length(IndexKeep)            if ~isempty(IndexKeep)                LongDwellData(a).LongDwellTime{b}         = Data(a).LongDwellTime(IndexKeep);                LongDwellData(a).LongDwellLocation{b}     = Data(a).LongDwellLocation(IndexKeep);                LongDwellData(a).PackagedDNA(b)           = sum(Data(a).PackagedDNA(IndexKeep));                LongDwellData(a).FrequencyOfLongPauses(b) = length(LongDwellData(a).LongDwellTime{b})/LongDwellData(a).PackagedDNA(b)*1000; %measured in "long pauses per kb of packaged DNA"                LongDwellData(a).TimeSpentInLongPauses(b) = sum(LongDwellData(a).LongDwellTime{b})/LongDwellData(a).PackagedDNA(b)*1000; %measured in "seconds spent in long pauses per kb of packaged DNA"                            else                LongDwellData(a).LongDwellTime{b}         = [];                LongDwellData(a).LongDwellLocation{b}     = [];                LongDwellData(a).PackagedDNA(b)           = 0;                LongDwellData(a).FrequencyOfLongPauses(b) = 0;                LongDwellData(a).TimeSpentInLongPauses(b) = 0;            end                        end    else        %there is no data for this atp concentration        RemoveIndex = [RemoveIndex a]; %this particular ATP concentration has no data, will be removed at the end    endend%--- Remove the Data structure components that contain no dataLongDwellData(RemoveIndex)='';%--- Ask the user where to save the Compiled DataSaveFile=[ResultsFolder '\' 'PropertiesOfLongPauses.mat'];uisave({'Data', 'LongDwellData'}, SaveFile);
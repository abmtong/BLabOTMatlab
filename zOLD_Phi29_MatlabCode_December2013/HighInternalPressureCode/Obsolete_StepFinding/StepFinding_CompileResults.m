function [Data StepData] = StepFinding_CompileResults()% Preparing the Data:% This function compiles and organizes the results from Step Finding. For each% day of data collection (for a particular condition) you create an index *.ind% file that contains the names of phage traces followed by a list of selected% feedback cycles that are well suited for step finding analysis. You process% these files with StepFinding_ProcessTrace.m which saves the results in a% *.mat file that corresponds to the respective *.ind file.%% If on one day you sampled a few different conditions (say two different ATP% concentration) you can create two different *.ind files that will generate two% different *.mat files with results. Then you need to organize all the *.mat% results according to their content. In our case we need dwell-time and% step-size information at different [ATP]. Create a separate StepFindingResults% (the actual folder name doesn't matter here) and create a series of subfolders% that refer to the ATP concentration at which the data was collected. For the% ATP-data folders, please use the following notation: "10uM" or "250uM". Folder% naming here actually matters because this function assumes the [ATP] from the% folder name. Next copy the *.mat results files (with dwell-time and step-size% data) into the corresponding [ATP] folder. Here the actual names of individual% *.mat don't matter. Make sure they are meaningful to you. Here's what this% Folder organization would look like:%% {StepFindingResults}:%                      {25uM}: 091210_Results.mat%                              091810_Results.mat%                              ...%                      {50uM}: 092010_Results.mat%                              ...%                      ...% Parameters:% You will have to specify a series of parameters that characterize the DNA% tether, as well as the data binning that you're planning to do. You can bin% the results in say 500bp bins and then look at the trends across different% bins and different ATP concentrations.%% Output Data Organization:% This function will read all *.mat files organized in [ATP] folders. Then it% will create a data structure "StepData". It is organized as follows:% StepData(1) contains data for the 1st ATP concentration% StepData(2) contains data for the 2nd ATP concentration % StepData(i) contains data for the ith ATP concentration%% Each structure contains a series of fields, for example:% StepData(3) =%%           ATP: 200%      BinStart: [1x12 double]%        BinEnd: [1x12 double]%     DwellTime: {1x12 cell}% DwellLocation: {1x12 cell}%      StepSize: {1x12 cell}%  StepLocation: {1x12 cell}%% You can see that StepData(3) corresponds to [ATP]=200uM. BinStart and BinEnd% define where the bin starts/end in bp of DNA packaged (19.3kb corresponds to% Phi29 100% genomic DNA packaged). In this case the data was binned in 12 bins.% You can access the list of step sizes for the 5th bin by referencing:% StepData(3).StepSize{5}%% Note that some of these cells may be empty if we have no data for that% particular [ATP] and capsid filling. At the end you will be asked to save the% compiled data structure in a *.mat file (if you want). The compiled data can% also be accessed as "StepData" from the MATLAB workspace (see USE).%% USE: [Data StepData] = StepFinding_CompileResults()%% Gheorghe Chistol, 27 Oct 2010%% Ask for the ParametersPrompt = {'Length of Packaged DNA(bp)',...          'DNA Length Bin Start (bp)',...          'DNA Length Bin End (bp)',...          'DNA Length Bin Width (bp)'};Title = 'Enter the Following Parameters';Lines = 1;Default = {'21000','17000','21000','500'};Options.Resize='on'; Options.WindowStyle='normal'; Options.Interpreter='tex';Answer = inputdlg(Prompt, Title, Lines, Default, Options);%Hist parameters refer to the histogram display at the endLengthDNA    = str2num(Answer{1}); %the length of packaged DNABinStart     = str2num(Answer{2});BinEnd       = str2num(Answer{3});BinWidth     = str2num(Answer{4});%% Ask the user to locate the StepFindingResults folderglobal analysisPath;if isempty(analysisPath)     disp('analysisPath not defined. Use "SetAnalysisPath" to define it');    return;elseif analysisPath==0    disp('analysisPath not defined. Use "SetAnalysisPath" to define it');    return;endResultsFolder = uigetdir(analysisPath , 'Select the Folder with Step Finding results');%% Get a list of all sub-folders in the ResultsFolder% index only the ones that are names 100uM, 250uM etc. These contain data at% that particular ATP concentration.ConcListATP   = []; %this is the list of available ATP concentrationsFolderListATP = {}; %this is the list of folders containing dwell/step data for a given [ATP]ItemList = dir(ResultsFolder); %get the list of all files and foldersfor i = 1:length(ItemList)    ItemName = ItemList(i).name;    ItemType = ItemList(i).isdir; %'1' for directories, '0' for files and others    if ItemType==1        %this is a directory        if length(ItemName)>2 && strcmp(ItemName(end-1:end),'uM') %check if the last two characters are uM            %disp(ItemName);            %this is most likely a valid folder for an ATP concentration            temp = ItemName(1:end-2); %this is supposed the be the value of the ATP concentration            temp = str2num(temp); %convert string to a number                        if temp>0                ConcListATP(end+1)   = temp; %in uM                FolderListATP{end+1} = ItemName;            end        end    endendif isempty(FolderListATP)    %no valid ATP folders were identified, quitting    disp('Failed to find any valid ATP data folders !');    disp('... Valid ATP folder names are 100uM or 25uM. Check your naming convention.')    return;end%sort the ATP concentration in ascending order and sort the folders%correspondingly. List all the folders to the user and proceed to loading and%organizing data[ConcListATP SortIndex] = sort(ConcListATP);FolderListATP           = FolderListATP(SortIndex);disp('This is the list of valid ATP data folders found:');for i=1:length(FolderListATP);     disp(FolderListATP{i}); end%% Go into each ATP folder, load all the files and organize the Data accordingly% All *.mat files will be loaded. Valid step/dwell data is organized in a data% structure called "FinalDwells".%for f=1:length(FolderListATP) %index "f" stands for "folder"    CurrentFolder = [ResultsFolder '\' FolderListATP{f}]; %need the full path    temp = what(CurrentFolder);    if ~isempty(temp)        MatFiles = temp.mat; %the list of *.mat files in this folder        if ~isempty(MatFiles) %load the data if there are any mat files, skip this folder otherwise            %we are using a temporary data pool that will be binned later            %DataPool is the name of said structure            Data(f).ATP           = ConcListATP(f); %this is the ATP concentration for the CurrentFolder            Data(f).DwellTime     = [];            Data(f).DwellLocation = [];            Data(f).StepSize      = [];            Data(f).StepLocation  = [];            for m=1:length(MatFiles)                CurrentFile = MatFiles{m};                clear FinalDwells; %this is the data structure in whichthe step/dwell data is saved                                   %here we're cleaning out the old data structure                                   %in preparation for the new one                load ([CurrentFolder '\' CurrentFile]);                disp(['... Loaded file: ' CurrentFolder '\' CurrentFile]);                                %we need to see if the "FinalDwells" data structure exists                WorkspaceItems = whos; %get all the items in the workspace                FinalDwells_Exist=0; %no FinalDwells cell found                for w=1:length(WorkspaceItems)                    if strcmp(WorkspaceItems(w).name,'FinalDwells') && strcmp(WorkspaceItems(w).class,'cell')                        FinalDwells_Exist=1; %such a cell exists, we can go further                    end                end                                if FinalDwells_Exist                    %we have the neccessary data, add it to the pool of already                    %available data, sort it later                    %FinalDwells{PhageIndex}{FeedbackCycle}                    for p=1:length(FinalDwells) %go through all the phages in the FinalDwells                        for fc=1:length(FinalDwells{p}) %go through all the feedback cycles for this particular phage                            if ~isempty(FinalDwells{p}{fc})  %only work with it if any steps were found                                if ~isempty(FinalDwells{p}{fc}.StepSize)                                     Data(f).DwellTime     = [Data(f).DwellTime     FinalDwells{p}{fc}.DwellTime]; %append to existing data                                    Data(f).DwellLocation = [Data(f).DwellLocation LengthDNA-FinalDwells{p}{fc}.DwellLocation]; %append to existing data                                    Data(f).StepSize      = [Data(f).StepSize      FinalDwells{p}{fc}.StepSize]; %append to existing data                                    Data(f).StepLocation  = [Data(f).StepLocation  LengthDNA-FinalDwells{p}{fc}.StepLocation]; %append to existing data                                %from now on Location refers to the amount of                                %packaged DNA (as opposed to the thether length)                                end                            end                        end                    end                else                    disp([CurrentFolder '\' CurrentFile ' does not contain valid data !']);                end            end        else            disp([CurrentFolder ' does not contain any *.mat files !']);        end    endend%% Initialize the Data structure that organizes the Data in binstemp = BinStart:BinWidth:BinEnd; %make the bins for binning velocity data based on the length of DNA packagedfor a=1:length(ConcListATP)    StepData(a).ATP           = ConcListATP(a);    StepData(a).BinStart      = temp(1:end-1); %starting of each bin    StepData(a).BinEnd        = temp(2:end);   %ending of each bin    StepData(a).DwellTime     = {}; %there will be a cell with data corresponding to each bin    StepData(a).DwellLocation = {}; %there will be a cell with data corresponding to each bin    StepData(a).StepSize      = {}; %there will be a cell with data corresponding to each bin    StepData(a).StepLocation  = {}; %there will be a cell with data corresponding to each binend% Now we have the pool of step/dwell data in "Data" and it needs to be% organized into bins to form "StepData" % Data(f).ATP           % Data(f).DwellTime     % Data(f).DwellLocation % Data(f).StepSize      % Data(f).StepLocation  RemoveIndex=[]; %this is the index of ATP concentrations that have no data and need to be removed at the endfor a=1:length(Data); %index a stands to "ATP", refers to various atp concentrations    if ~isempty(Data(a).DwellTime)        BinStart = StepData(a).BinStart;        BinEnd   = StepData(a).BinEnd;                for b=1:length(BinStart) %index b refers to Bins            CurrentBinStart = BinStart(b);            CurrentBinEnd   = BinEnd(b);                        %-------------- Organize Dwell Data separately            IndSmaller = Data(a).DwellLocation < CurrentBinEnd; %index of all the points smaller than upper limit            IndLarger  = Data(a).DwellLocation > CurrentBinStart; %index of all the points largert than lower limit             IndexKeep  = logical(IndLarger.*IndSmaller); %the index of the dwells that belong to the current bin                        if ~isempty(IndexKeep)                StepData(a).DwellTime{b}     = Data(a).DwellTime(IndexKeep); %record the data that belongs to the current bin                StepData(a).DwellLocation{b} = Data(a).DwellLocation(IndexKeep); %record the data that belongs to the current bin            end                        %-------------- Organize Step Data separately            IndSmaller = Data(a).StepLocation < CurrentBinEnd; %index of all the points smaller than upper limit            IndLarger  = Data(a).StepLocation > CurrentBinStart; %index of all the points largert than lower limit             IndexKeep  = logical(IndLarger.*IndSmaller); %the index of the steps that belong to the current bin                        if ~isempty(IndexKeep)                StepData(a).StepSize{b}     = Data(a).StepSize(IndexKeep); %record the data that belongs to the current bin                StepData(a).StepLocation{b} = Data(a).StepLocation(IndexKeep); %record the data that belongs to the current bin            end        end    else        %there is no data for this atp concentration        RemoveIndex = [RemoveIndex a]; %this particular ATP concentration has no data, will be removed at the end    endend%--- Remove the Data structure components that contain no dataStepData(RemoveIndex)='';%--- Ask the user where to save the Compiled DataSaveFile=[ResultsFolder '\' 'CompiledSteppingData.mat'];uisave({'Data','StepData'}, SaveFile);
function Results = Generate_StepSizeandDwellTimeHistogram()% Load a Results file (or multiple results files corresponding to the same% conditions) with StepSize data from StepFinding and generate the Step% Size histogram. This function will also do some smart merging of nearby% short steps based on a simple set of rules.%% USE: [StepSize RevisedStepSize] = Generate_StepSizeHistogram()%% Gheorghe Chistol, 08 Feb 2011%% Ask for the ParametersPrompt = {'Step Size Histogram Bin Size (bp)',...          'Substrate DNA Contour (bp)',...          'Display Results: Filling Bin Size (bp)',...          'Display Results: Lower Limit Filling (bp)',...          'Display Results: Upper Limit Filling (bp)',...          'StepMerging: Max Allowed Small Step (bp)',...          'StepMerging: Max Allowed Burst Size (bp)',...          'StepMerging: Max Allowed Dwell Between Added Steps (sec)',...          'CutoffAnalysis: Min Allowed Burst Size (bp)'};Title = 'Enter the Following Parameters';Lines = 1;Default = {'0.5','6000','6000','4000','6000','9','11','.1','8.5'};Options.Resize='on'; Options.WindowStyle='normal'; Options.Interpreter='tex';Answer = inputdlg(Prompt, Title, Lines, Default, Options);StepSizeBinSize        = str2num(Answer{1}); %#ok<*ST2NM>SubstrateContour       = str2num(Answer{2});ResultBinning          = str2num(Answer{3});LowerLimitFilling      = str2num(Answer{4});UpperLimitFilling      = str2num(Answer{5});MaxSmallStep           = str2num(Answer{6});MaxAllowedBurst        = str2num(Answer{7});MaxAllowedDwellBetween = str2num(Answer{8});MinAllowedBurst        = str2num(Answer{9}); %in bp%% Global Variables and select the folder where Step/Dwell Data is storedglobal analysisPath;if isempty(analysisPath)   disp('analysisPath not defined. Use "SetAnalysisPath" to define it'); return;end%Select one or more MAT results files from StepFinding that correspond to%the same conditions (ATP, substrate)[DataFile DataPath] = uigetfile([ [analysisPath filesep ] '*.mat'], 'Please select one or more Results files','MultiSelect', 'on');if isempty(DataFile) %if no files were selected    disp('No *.mat phage files were selected');return;endif ~iscell(DataFile) %if there is only one file, make it into a cell, for easier processing later    temp=DataFile; clear DataFile; DataFile{1}=temp;endAllResults.DwellTime=[];AllResults.StepSize=[];AllResults.StepFilling = [];AllResultsAfterMerge.DwellTime=[];AllResultsAfterMerge.StepSize=[];AllResultsAfterMerge.StepFilling = [];MergedSteps.FirstDwellTime=[];MergedSteps.SecondDwellTime=[];MergedSteps.TotalDwellTime=[];MergedSteps.FirstStepSize=[];MergedSteps.SecondStepSize=[];MergedSteps.TotalStepSize=[];MergedSteps.TotalStepFilling=[];CutoffResults.DwellTime=[]; %the dwell before the corresponding StepSizeCutoffResults.StepSize=[]; %apply a cutoff for step size from the AllResults populationCutoffResults.StepFilling=[];CutoffResultsAfterMerge.DwellTime=[];CutoffResultsAfterMerge.StepSize=[];CutoffResultsAfterMerge.StepFilling=[];for DF=1:length(DataFile) %DF is the index for DataFile    load([DataPath filesep DataFile{DF}]); %data is stored in the data structure FinalDwells    disp(['Loaded File ' DataFile{DF}]);    %FinalDwells{FileIndex}{FeedbackCycleIndex}    for FileIndex=1:length(FinalDwells) %#ok<*USENS> %go through all traces in FinalDwells               for FeedbackCycleIndex=1:length(FinalDwells{FileIndex}) %go through all feedback cycles for each trace                      if ~isempty(FinalDwells{FileIndex}{FeedbackCycleIndex}) %make sure it's not empty, sometimes it happens               tempDwellTime = FinalDwells{FileIndex}{FeedbackCycleIndex}.DwellTime;               tempStepSize  = -FinalDwells{FileIndex}{FeedbackCycleIndex}.StepSize;               tempStepFilling = SubstrateContour-FinalDwells{FileIndex}{FeedbackCycleIndex}.StepLocation; %this gives us the capsid filling at which this step was taken                           tempRevisedStepSize  = tempStepSize; %this one will undergo step merging               tempRevisedDwellTime = tempDwellTime; %this will undergo updates as the merging happens                tempRevisedStepFilling = tempStepFilling; %this will be updated as we merge steps               %now go through the step size from the current feedback cycle               %and merge consecutive short steps               s=1;               while s<length(tempRevisedStepSize)                   %MaxSmallStep           = 7;                   %MaxAllowedBurst        = 13;                   %MaxAllowedDwellBetween = 0.5;                   if s+1<=length(tempRevisedStepSize)                       %there is at least one follow-up step, so we can check                       %if we can merge it with the current step                       Step1=tempRevisedStepSize(s);                       Step2=tempRevisedStepSize(s+1);                       Dwell1 = tempRevisedDwellTime(s);                       Dwell2 = tempRevisedDwellTime(s+1);                       if max([Step1 Step2])<MaxSmallStep && Step1+Step2<MaxAllowedBurst && Dwell2<MaxAllowedDwellBetween                           %each individual step is small enough and their sum                           %is not larger than the max allowed burst, also, the                           %dwell between them is not too long                           %go ahead and merge                           tempRevisedStepSize(s)=Step1+Step2;                           tempRevisedStepSize(s+1)=[]; %remove the next step, it was merged with the current step                           tempRevisedDwellTime(s)= Dwell1+Dwell2;                           tempRevisedDwellTime(s+1)=[]; %remove the next step, it was merged with the current step                           tempRevisedStepFilling(s+1)=[]; %remove the entry corresponding to the second step                                                      MergedSteps.FirstDwellTime(end+1)=Dwell1;                           MergedSteps.SecondDwellTime(end+1)=Dwell2;                           MergedSteps.TotalDwellTime(end+1)=Dwell1+Dwell2;                                                       MergedSteps.FirstStepSize(end+1)  = Step1;                           MergedSteps.SecondStepSize(end+1) = Step2;                           MergedSteps.TotalStepSize(end+1)  = Step1+Step2;                           MergedSteps.TotalStepFilling(end+1) = tempRevisedStepFilling(s);                            s=s+1; %move to the following step;                       else                           s=s+1; %can't merge, go on to the next step                       end                   else                       s=s+1; %move on                   end               end               AllResultsAfterMerge.DwellTime   = [AllResultsAfterMerge.DwellTime   tempRevisedDwellTime];               AllResultsAfterMerge.StepSize    = [AllResultsAfterMerge.StepSize    tempRevisedStepSize];               AllResultsAfterMerge.StepFilling = [AllResultsAfterMerge.StepFilling tempRevisedStepFilling];                              AllResults.DwellTime   = [AllResults.DwellTime tempDwellTime];               AllResults.StepSize    = [AllResults.StepSize tempStepSize];               AllResults.StepFilling = [AllResults.StepFilling tempStepFilling];               %find the Steps that are larger than the cutoff size                              KeepersInd = tempStepSize>MinAllowedBurst; %index of all step-sizes larger than MinAllowedBurst               CutoffResults.StepSize  = [CutoffResults.StepSize  tempStepSize(KeepersInd)]; %apply a cutoff for step size from the AllResults population               CutoffResults.DwellTime = [CutoffResults.DwellTime tempDwellTime(KeepersInd)]; %the dwell before the corresponding StepSize               CutoffResults.StepFilling  = [CutoffResults.StepFilling  tempStepFilling(KeepersInd)];                              KeepersInd = tempRevisedStepSize>MinAllowedBurst; %index of all step-sizes larger than MinAllowedBurst               CutoffResultsAfterMerge.StepSize  = [CutoffResultsAfterMerge.StepSize  tempRevisedStepSize(KeepersInd)]; %apply a cutoff for step size from the AllResults population               CutoffResultsAfterMerge.DwellTime = [CutoffResultsAfterMerge.DwellTime tempRevisedDwellTime(KeepersInd)]; %the dwell before the corresponding StepSize               CutoffResultsAfterMerge.StepFilling  = [CutoffResultsAfterMerge.StepFilling  tempRevisedStepFilling(KeepersInd)];           end       end    endend%% We finished compiling all the data together%now bin the data depending on filling%StepSizeBinSize  = str2num(Answer{1});%SubstrateContour = str2num(Answer{2});%ResultBinning    = str2num(Answer{3});%MaxSmallStep     = str2num(Answer{4});%MaxAllowedBurst  = str2num(Answer{5});%MaxAllowedDwellBetween = str2num(Answer{6});%MinAllowedBurst  = str2num(Answer{7}); %in bpFillingIntervals=LowerLimitFilling:ResultBinning:UpperLimitFilling;%             Results(fr).MinFilling%             Results(fr).MaxFilling %fr is the index for FillingRange%         Results(fr).AllResults.DwellTime%                               .StepSize%         Results(fr).CutoffResults.DwellTime%                                  .StepSize%         Results(fr).MergedSteps.FirstDwellTime%                                .SecondDwellTime%                                .FirstStepSize%                                .SecondStepSize%                                .TotalDwellTime%                                .TotalStepSize for fr=1:length(FillingIntervals)-1    Results(fr).MinFilling=FillingIntervals(fr);    Results(fr).MaxFilling=FillingIntervals(fr+1);        %define the min and the max for the current situation    CurrMaxFill=Results(fr).MaxFilling;     CurrMinFill=Results(fr).MinFilling;        %looking at AllResults first    Keepers=AllResults.StepFilling<CurrMaxFill & AllResults.StepFilling>CurrMinFill;    Results(fr).AllResults.StepSize  = AllResults.StepSize(Keepers);    Results(fr).AllResults.DwellTime = AllResults.DwellTime(Keepers);        %looking at AllResultsAfterMerge     Keepers = AllResultsAfterMerge.StepFilling<CurrMaxFill & AllResultsAfterMerge.StepFilling>CurrMinFill;    Results(fr).AllResultsAfterMerge.StepSize  = AllResultsAfterMerge.StepSize(Keepers);    Results(fr).AllResultsAfterMerge.DwellTime = AllResultsAfterMerge.DwellTime(Keepers);    %looking at CutoffResults    Keepers=CutoffResults.StepFilling<CurrMaxFill & CutoffResults.StepFilling>CurrMinFill;    Results(fr).CutoffResults.StepSize  = CutoffResults.StepSize(Keepers);    Results(fr).CutoffResults.DwellTime = CutoffResults.DwellTime(Keepers);        %looking at CutoffResultsAfterMerge    Keepers=CutoffResultsAfterMerge.StepFilling<CurrMaxFill & CutoffResultsAfterMerge.StepFilling>CurrMinFill;    Results(fr).CutoffResultsAfterMerge.StepSize  = CutoffResultsAfterMerge.StepSize(Keepers);    Results(fr).CutoffResultsAfterMerge.DwellTime = CutoffResultsAfterMerge.DwellTime(Keepers);        %Looking at MergedSteps part    Keepers=MergedSteps.TotalStepFilling<CurrMaxFill & MergedSteps.TotalStepFilling>CurrMinFill;    Results(fr).MergedSteps.FirstDwellTime  = MergedSteps.FirstDwellTime(Keepers);    Results(fr).MergedSteps.SecondDwellTime = MergedSteps.SecondDwellTime(Keepers); %#ok<*AGROW>    Results(fr).MergedSteps.TotalDwellTime  = MergedSteps.TotalDwellTime(Keepers);    Results(fr).MergedSteps.FirstStepSize   = MergedSteps.FirstStepSize(Keepers);    Results(fr).MergedSteps.FirstStepSize   = MergedSteps.FirstStepSize(Keepers);    Results(fr).MergedSteps.SecondStepSize  = MergedSteps.SecondStepSize(Keepers);    Results(fr).MergedSteps.TotalStepSize   = MergedSteps.TotalStepSize(Keepers);    end%% Go through each Filling Range and plot its contentsfor fr=1:length(Results)    %define the min and the max for the current situation    CurrMaxFill=Results(fr).MaxFilling;     CurrMinFill=Results(fr).MinFilling;        if ~isempty(Results(fr).AllResults.StepSize)                %Plot the StepSize First        StepSizeBins=-10:StepSizeBinSize:15;        figure('Units','normalized','Position',[ 0.005 0.0533 0.49 0.86]);        temp=Results(fr).AllResults.StepSize;        temp=temp(temp>-20&temp<20);        if ~isempty(temp)            subplot(4,2,1);            %hist(temp,StepSizeBins);            [f x]=ksdensity(temp);            plot(x,f);            title(['Filling Range: ' num2str(CurrMinFill) 'bp-' num2str(CurrMaxFill) 'bp' ]);            ylabel('All Steps');            set(gca,'XLim',[-15 15]);            Mean = round(10*mean(temp))/10;            Std  = round(10*std(temp))/10;            legend( [num2str(Mean) '{\pm}' num2str(Std) 'bp'],'Location','nw' );        end              temp=Results(fr).AllResultsAfterMerge.StepSize;        temp=temp(temp>-20&temp<20);        if ~isempty(temp)            subplot(4,2,3);            %hist(temp,StepSizeBins);            [f x]=ksdensity(temp);            plot(x,f);            ylabel('AllResultsAfterMerge');            set(gca,'XLim',[-15 15]);            Mean = round(10*mean(temp))/10;            Std  = round(10*std(temp))/10;            legend( [num2str(Mean) '{\pm}' num2str(Std) 'bp'],'Location','nw' );        end                temp=Results(fr).CutoffResults.StepSize;        temp=temp(temp>-20&temp<20);                if ~isempty(temp)            subplot(4,2,5);            hist(temp,StepSizeBins);            ylabel('Cutoff Steps');            set(gca,'XLim',[-15 15]);            Mean = round(10*mean(temp))/10;            Std  = round(10*std(temp))/10;            legend( [num2str(Mean) '{\pm}' num2str(Std) 'bp'],'Location','nw' );        end                temp=Results(fr).CutoffResultsAfterMerge.StepSize;        temp=temp(temp>-20&temp<20);                if ~isempty(temp)            subplot(4,2,7);            hist(temp,StepSizeBins);            ylabel('CutoffResultsAfterMerge');            xlabel('Step Size (bp)');            set(gca,'XLim',[-15 15]);            Mean = round(10*mean(temp))/10;            Std  = round(10*std(temp))/10;            legend( [num2str(Mean) '{\pm}' num2str(Std) 'bp'],'Location','nw' );        end                temp=Results(fr).AllResults.DwellTime;        if ~isempty(temp)            subplot(4,2,2);            hist(temp);            title(['Filling Range: ' num2str(CurrMinFill) 'bp-' num2str(CurrMaxFill) 'bp' ]);            ylabel('All Dwells');            Nmin  = (mean(temp))^2/((mean(temp.^2))-(mean(temp))^2);            Nmin  = round(10*Nmin)/10;            MeanT = round(1000*mean(temp));            legend( ['<T>=' num2str(MeanT) 'ms, Nmin=' num2str(Nmin)],'Location','ne' );        end        temp=Results(fr).AllResultsAfterMerge.DwellTime;        if ~isempty(temp)            subplot(4,2,4);            hist(temp);            ylabel('AllDwellsAfterMerge');            Nmin  = (mean(temp))^2/((mean(temp.^2))-(mean(temp))^2);            Nmin  = round(10*Nmin)/10;            MeanT = round(1000*mean(temp));            legend( ['<T>=' num2str(MeanT) 'ms, Nmin=' num2str(Nmin)],'Location','ne' );        end                temp=Results(fr).CutoffResults.DwellTime;        if ~isempty(temp)            subplot(4,2,6);            hist(temp);            ylabel('Cutoff Dwells');            Nmin  = (mean(temp))^2/((mean(temp.^2))-(mean(temp))^2);            Nmin  = round(10*Nmin)/10;            MeanT = round(1000*mean(temp));            legend( ['<T>=' num2str(MeanT) 'ms, Nmin=' num2str(Nmin)],'Location','ne' );        end                temp=Results(fr).CutoffResultsAfterMerge.DwellTime;        if ~isempty(temp)            subplot(4,2,8);            hist(temp);            ylabel('CutoffDwellsAfterMerge');            xlabel('Dwell Time (sec)');            Nmin  = (mean(temp))^2/((mean(temp.^2))-(mean(temp))^2);            Nmin  = round(10*Nmin)/10;            MeanT = round(1000*mean(temp));            legend( ['<T>=' num2str(MeanT) 'ms, Nmin=' num2str(Nmin)],'Location','ne' );        end    endend
function Results=CompileSaturatingATP_DwellTimeHistograms()% Load and organize the dwell time histograms for saturating ATP% experiments. You have to organize your *results.mat files in separate% folders named as follows% 15kb% 17kb% 21kb% etc, denoting the tether length used%% USE: [Bin Data]=CompileSaturatingATP_DwellTimeHistograms()%% Gheorghe Chistol, 17 Jan 2011%% Ask for the ParametersPrompt = {'Dwell Time Histogram Bin Size (sec)','Min Capsid Filling (bp)',...          'Max Capsid Filling (bp)','Capsid Filling Increment (bp)'};Title = 'Enter the Following Parameters';Lines = 1;Default = {'0.1','15000','20000','500'};Options.Resize='on'; Options.WindowStyle='normal'; Options.Interpreter='tex';Answer = inputdlg(Prompt, Title, Lines, Default, Options);%Hist parameters refer to the histogram display at the endDwellTimeBinSize = str2num(Answer{1});MinCapsidFilling = str2num(Answer{2});MaxCapsidFilling = str2num(Answer{3});FillingBinSize   = str2num(Answer{4}); %the length of packaged DNA%% Global Variables and select the folder where Step/Dwell Data is storedglobal analysisPath;if isempty(analysisPath)   disp('analysisPath not defined. Use "SetAnalysisPath" to define it');   return;endDataPath = uigetdir(analysisPath,'Please Select the Folder where Step Data is Stored'); temp = MinCapsidFilling:FillingBinSize:MaxCapsidFilling; %make the bins for binning velocity data based on the length of DNA packagedFillingBinStart  = temp(1:end-1); %starting of each binFillingBinFinish = temp(2:end);   %ending of each bin%% Get the names of all items in the DataPath, focus on the folders onlyDataPathContent = dir(DataPath);SubstrateLength = []; %the list of all DNA substrates being consideredSubstratePath   = {}; %the list of all folders in which data is storedfor i=1:length(DataPathContent)    if DataPathContent(i).isdir && length(DataPathContent(i).name)>2         %needs to be a folder and have a name longer than 2 characters, for        %example 3kb or 15kb, etc        if strcmp(DataPathContent(i).name(end-1:end),'kb')            %this folder name ends in kb, therefore is what we need            %check that the firt part of the folder name is an actual number            temp=str2num(DataPathContent(i).name(1:end-2));            if temp>0 && temp<25                SubstrateLength(end+1) = temp; %in kb                SubstratePath{end+1}   = DataPathContent(i).name; %name of the folder            end        end    endend%% Now that we know what we have, proceed to load the data and sort itFilling   = []; %the list of Filling(s) corresponding to the list of DwellTime(s)DwellTime = [];for Substrate=1:length(SubstratePath)    %see how many *.mat files there are in each folder    temp=what([DataPath '\' SubstratePath{Substrate} '\'],'mat');    MatFileList=temp.mat; %the list of all mat files;    if ~isempty(MatFileList) %if there are any files found        for MatFile=1:length(MatFileList)            MatFilePath=[DataPath '\' SubstratePath{Substrate} '\' MatFileList{MatFile}];            load(MatFilePath); %data is stored in the data structure FinalDwells            disp(['Loaded File ' MatFilePath]);            %FinalDwells{FileIndex}{FeedbackCycleIndex}            for FileIndex=1:length(FinalDwells)               for FeedbackCycleIndex=1:length(FinalDwells{FileIndex})                   if ~isempty(FinalDwells{FileIndex}{FeedbackCycleIndex}) %make sure it's not empty, sometimes it happens                       Filling   = [Filling   SubstrateLength(Substrate)*1000-FinalDwells{FileIndex}{FeedbackCycleIndex}.DwellLocation];                       DwellTime = [DwellTime FinalDwells{FileIndex}{FeedbackCycleIndex}.DwellTime];                   end               end            end        end    endend%% Now that we have the DwellTime and Filling arrays, sort into binsclose all;for Bin=1:length(FillingBinStart)    Results(Bin).Start  = FillingBinStart(Bin);    Results(Bin).Finish = FillingBinFinish(Bin);    Keepers = Filling<Results(Bin).Finish & Filling>Results(Bin).Start;    Results(Bin).Filling   = Filling(Keepers);     Results(Bin).DwellTime = DwellTime(Keepers);    if ~isempty(Results(Bin).DwellTime)                HistBins=DwellTimeBinSize/2:DwellTimeBinSize:max(Results(Bin).DwellTime)+DwellTimeBinSize;        [N,D]=hist(Results(Bin).DwellTime,HistBins);        if N(1)<N(2)            D(1)='';            N(1)='';        end        if Results(Bin).Finish>18e3            Ind=D>1; %consolidate data corresponding to 1sec and longer            c=Ind(1); %starting point            Nmax=3; %bunch by bins of 3            n=1;            while c<length(D) && n<=Nmax                if n==1                    D(c)=(D(c)+D(c+1))/2;                elseif n==2                    D(c)=(2*D(c)+D(c+1))/3;                else                    D(c)=(3*D(c)+D(c+1))/4;                end                N(c)=N(c)+N(c+1);                D(c+1)='';                N(c+1)='';                n=n+1;                if n==Nmax                    c=c+1;                    n=1;                end            end               %fitting the data to a double exponential            GuessParam = [N(1) N(1)/10 10 0.1];            LowerLimit = [0 0 0 0];            FitType    = fittype('a1*exp(-k1*x)+a2*exp(-k2*x)','dependent',{'y'},'independent',{'x'},'coefficients',{'a1','a2','k1','k2'});            Options    = fitoptions('Method','NonlinearLeastSquares','StartPoint',GuessParam,'MaxIter',10000,'Lower',LowerLimit);            KeepInd    = isfinite(D) & isfinite(N); %the index of all data that is non NaN or meaningless            FitResults = fit(D(KeepInd)', N(KeepInd)',FitType,Options);        else            %fitting the data to a single exponential            GuessParam = [N(1) 10];            LowerLimit = [0 0];            FitType    = fittype('a1*exp(-k1*x)','dependent',{'y'},'independent',{'x'},'coefficients',{'a1','k1'});            Options    = fitoptions('Method','NonlinearLeastSquares','StartPoint',GuessParam,'MaxIter',10000,'Lower',LowerLimit);            KeepInd    = isfinite(D) & isfinite(N); %the index of all data that is non NaN or meaningless            FitResults = fit(D(KeepInd)', N(KeepInd)',FitType,Options);        end        Results(Bin).N=N;        Results(Bin).D=D;        Results(Bin).FitResults=FitResults;        t=Results(Bin).DwellTime; %the list of all dwelltimes        ind=t<2;        t=t(ind);        Results(Bin).Nmin=(mean(t))^2/(mean(t.^2)-(mean(t))^2);                figure; hold on;        plot(D,N,'.k');        plot(FitResults);        %set(gca,'YScale','log');        set(gca,'XLim',[0 10]);        set(gca,'YLim',[0.1 max(N)]);        title(['Capsid Filling ' num2str(Results(Bin).Start) '-' num2str(Results(Bin).Finish) 'kb; N=' num2str(length(Results(Bin).DwellTime)) '; Nmin=' num2str(Results(Bin).Nmin)]);        xlabel('Dwell Time (sec)');        ylabel('log(Count)');                %Now calculate the fraction of dwells that belong to the fast group        %(the predominant one)        %CoeffValues  = coeffvalues(FitResults);        %ConfInterval = confint(FitResults); %96% confidence interval    endendfor Bin=1:length(Results)    CoeffValues  = coeffvalues(Results(Bin).FitResults);    if length(CoeffValues)==2 %fitting a single exponential       k=['k=' num2str(CoeffValues(2))];       FracN1=1;    else       k=['k1=' num2str(CoeffValues(3)) ', k2=' num2str(CoeffValues(4))];       N1=CoeffValues(1)/CoeffValues(3);       N2=CoeffValues(2)/CoeffValues(4);       FracN1=N1/(N1+N2);    end    N=length(Results(Bin).Filling);    temp=['N=' num2str(N) '; FractionN1=' num2str(round(FracN1*100)) '%; ' k];    disp(temp);end
function [Data CorrData] = StepFinding_CalculateLongPauseCorrelations()% Preparing the Data:% {StepFindingResults}:%                      {25uM}: 091210_Results.mat%                              091810_Results.mat%                              ...%                      {50uM}: 092010_Results.mat%                              ...%                      ...% Parameters:% You will have to specify a series of parameters that characterize the DNA% tether, as well as the data binning that you're planning to do. You can bin% the results in say 500bp bins and then look at the trends across different% bins and different ATP concentrations.%% Output Data Organization:% This function will read all *.mat files organized in [ATP] folders. Then it% will create a data structure "StepData". It is organized as follows:% StepData(1) contains data for the 1st ATP concentration% StepData(2) contains data for the 2nd ATP concentration % StepData(i) contains data for the ith ATP concentration%% Each structure contains a series of fields, for example:% StepData(3) =%%           ATP: 200%      BinStart: [1x12 double]%        BinEnd: [1x12 double]%     DwellTime: {1x12 cell}% DwellLocation: {1x12 cell}%      StepSize: {1x12 cell}%  StepLocation: {1x12 cell}%% USE: [Data CorrData] = StepFinding_CalculateLongPauseCorrelations()% Gheorghe Chistol, 01 Nov 2010%% Ask for the ParametersPrompt = {'Length of Packaged DNA(bp)',...          'DNA Length Bin Start (bp)',...          'DNA Length Bin End (bp)',...          'DNA Length Bin Width (bp)',...          'Long Dwell Lower Limit (sec)'};  Title = 'Enter the Following Parameters';Lines = 1;Default = {'21000','17000','21000','500','1'};Options.Resize='on'; Options.WindowStyle='normal'; Options.Interpreter='tex';Answer = inputdlg(Prompt, Title, Lines, Default, Options);%Hist parameters refer to the histogram display at the endLengthDNA           = str2num(Answer{1}); %the length of packaged DNABinStart            = str2num(Answer{2});BinEnd              = str2num(Answer{3});BinWidth            = str2num(Answer{4});LongDwellLowerLimit = str2num(Answer{5});%% Ask the user to locate the StepFindingResults folderglobal analysisPath;if isempty(analysisPath)     disp('analysisPath not defined. Use "SetAnalysisPath" to define it');    return;elseif analysisPath==0    disp('analysisPath not defined. Use "SetAnalysisPath" to define it');    return;endResultsFolder = uigetdir(analysisPath , 'Select the Folder with Step Finding results');%% Get a list of all sub-folders in the ResultsFolder% index only the ones that are names 100uM, 250uM etc. These contain data at% that particular ATP concentration.ConcListATP   = []; %this is the list of available ATP concentrationsFolderListATP = {}; %this is the list of folders containing dwell/step data for a given [ATP]ItemList = dir(ResultsFolder); %get the list of all files and foldersfor i = 1:length(ItemList)    ItemName = ItemList(i).name;    ItemType = ItemList(i).isdir; %'1' for directories, '0' for files and others    if ItemType==1        %this is a directory        if length(ItemName)>2 && strcmp(ItemName(end-1:end),'uM') %check if the last two characters are uM            %disp(ItemName);            %this is most likely a valid folder for an ATP concentration            temp = ItemName(1:end-2); %this is supposed the be the value of the ATP concentration            temp = str2num(temp); %convert string to a number                        if temp>0                ConcListATP(end+1)   = temp; %in uM                FolderListATP{end+1} = ItemName;            end        end    endendif isempty(FolderListATP)    %no valid ATP folders were identified, quitting    disp('Failed to find any valid ATP data folders !');    disp('... Valid ATP folder names are 100uM or 25uM. Check your naming convention.')    return;end%sort the ATP concentration in ascending order and sort the folders%correspondingly. List all the folders to the user and proceed to loading and%organizing data[ConcListATP SortIndex] = sort(ConcListATP);FolderListATP           = FolderListATP(SortIndex);disp('This is the list of valid ATP data folders found:');for i=1:length(FolderListATP);     disp(FolderListATP{i}); end%% Go into each ATP folder, load all the files and organize the Data accordingly% All *.mat files will be loaded. Valid step/dwell data is organized in a data% structure called "FinalDwells".%for f=1:length(FolderListATP) %index "f" stands for "folder"    CurrentFolder = [ResultsFolder '\' FolderListATP{f}]; %need the full path    temp = what(CurrentFolder);    if ~isempty(temp)        MatFiles = temp.mat; %the list of *.mat files in this folder        if ~isempty(MatFiles) %load the data if there are any mat files, skip this folder otherwise            %we are using a temporary data pool that will be binned later            %DataPool is the name of said structure            Data(f).ATP                   = ConcListATP(f); %this is the ATP concentration for the CurrentFolder            Data(f).LongDwellLocation     = [];            Data(f).LongDwellTime         = [];            Data(f).NextLongDwellTime     = [];            Data(f).DistanceSeparation    = [];            Data(f).TemporalSeparation    = [];            for m=1:length(MatFiles)                CurrentFile = MatFiles{m};                clear FinalDwells; %this is the data structure in whichthe step/dwell data is saved                                   %here we're cleaning out the old data structure                                   %in preparation for the new one                load ([CurrentFolder '\' CurrentFile]);                disp(['... Loaded file: ' CurrentFolder '\' CurrentFile]);                                %we need to see if the "FinalDwells" data structure exists                WorkspaceItems = whos; %get all the items in the workspace                FinalDwells_Exist=0; %no FinalDwells cell found                for w=1:length(WorkspaceItems)                    if strcmp(WorkspaceItems(w).name,'FinalDwells') && strcmp(WorkspaceItems(w).class,'cell')                        FinalDwells_Exist=1; %such a cell exists, we're good to go further                    end                end                                if FinalDwells_Exist                    %we have the neccessary data, add it to the pool of already                    %available data, sort it later                    %FinalDwells{PhageIndex}{FeedbackCycle}                    for p=1:length(FinalDwells) %go through all the phages in the FinalDwells                        for fc=1:length(FinalDwells{p}) %go through all the feedback cycles for this particular phage                            if ~isempty(FinalDwells{p}{fc})  %only work with it if any steps were found                                if ~isempty(FinalDwells{p}{fc}.DwellTime)                                     %index d refers to "dwell" we are looking                                    %only at dwells longer than                                    %LongDwellLowerLimit and calculating how far                                    %away long dwells are (in time and space)                                    LongDwellIndex = find(FinalDwells{p}{fc}.DwellTime > LongDwellLowerLimit);                                    length(LongDwellIndex)                                    length(FinalDwells{p}{fc}.DwellTime)%                                   Data(f).ATP                   %                                   Data(f).LongDwellLocation     %                                   Data(f).LongDwellTime     %                                   Data(f).NextLongDwellTime %                                   Data(f).DistanceSeparation    %                                   Data(f).TemporalSeparation                                        %look at the nearest long dwells only                                    for LD=1:length(LongDwellIndex) %index LD refers to "long dwells"                                        if LD~=length(LongDwellIndex) %as long as the current long dwell is not the last dwell in this feedback trace                                            CurrentLongDwellIndex    = LongDwellIndex(LD);                                            NextLongDwellIndex       = LongDwellIndex(LD+1);                                            CurrentLongDwellTime     = FinalDwells{p}{fc}.DwellTime(CurrentLongDwellIndex);                                            NextLongDwellTime        = FinalDwells{p}{fc}.DwellTime(NextLongDwellIndex);                                            CurrentLongDwellLocation = LengthDNA-FinalDwells{p}{fc}.DwellLocation(CurrentLongDwellIndex);                                            NextLongDwellLocation    = LengthDNA-FinalDwells{p}{fc}.DwellLocation(NextLongDwellIndex);                                            %from now on Location refers to the amount of                                            %packaged DNA (as opposed to the thether length)                                            Data(f).LongDwellLocation(end+1)  = CurrentLongDwellLocation;                                            Data(f).LongDwellTime(end+1)      = CurrentLongDwellTime;                                             Data(f).NextLongDwellTime(end+1)  = NextLongDwellTime;                                             Data(f).DistanceSeparation(end+1) = abs(CurrentLongDwellLocation-NextLongDwellLocation);                                            %if the two long dwells are                                            %consecutive, their temporal                                            %separation is zero, if not,                                            %then their temporal separation                                            %equals the sum of the dwell                                            %times in between                                            if NextLongDwellIndex == (CurrentLongDwellIndex+1)                                                %these two long dwells are consecutive                                                Data(f).TemporalSeparation(end+1) = 0;                                            else                                                %these two long dwells are                                                %not consecutive, their                                                %temporal separation is the                                                %sum of all "in-between"                                                %dwells                                                %CurrentLongDwellIndex                                                %NextLongDwellIndex                                                Data(f).TemporalSeparation(end+1) = sum(FinalDwells{p}{fc}.DwellTime(CurrentLongDwellIndex+1:NextLongDwellIndex-1));                                            end                                        end                                    end                                end                            end                        end                    end                else                    disp([CurrentFolder '\' CurrentFile ' does not contain valid data !']);                end            end        else            disp([CurrentFolder ' does not contain any *.mat files !']);        end    endend%% Initialize the Data structure that organizes the Data in binstemp = BinStart:BinWidth:BinEnd; %make the bins for binning velocity data based on the length of DNA packaged%"CorrData" stads for CorrelationDatafor a=1:length(ConcListATP)    CorrData(a).ATP                = ConcListATP(a);    CorrData(a).BinStart           = temp(1:end-1); %starting of each bin    CorrData(a).BinEnd             = temp(2:end);   %ending of each bin    CorrData(a).LongDwellLocation  = {}; %there will be a cell with data corresponding to each bin    CorrData(a).LongDwellTime      = {}; %there will be a cell with data corresponding to each bin    CorrData(a).NextLongDwellTime  = {}; %there will be a cell with data corresponding to each bin    CorrData(a).DistanceSeparation = {}; %there will be a cell with data corresponding to each bin    CorrData(a).TemporalSeparation = {}; %there will be a cell with data corresponding to each binend% Data(i).ATP                % Data(i).LongDwellLocation  % Data(i).DistanceSeparation % Data(i).TemporalSeparationRemoveIndex=[]; %this is the index of ATP concentrations that have no data and need to be removed at the endfor a=1:length(Data); %index a stands to "ATP", refers to various atp concentrations    if ~isempty(Data(a).LongDwellLocation)        BinStart = CorrData(a).BinStart;        BinEnd   = CorrData(a).BinEnd;                for b=1:length(BinStart) %index b refers to Bins            CurrentBinStart = BinStart(b);            CurrentBinEnd   = BinEnd(b);                        %-------------- Organize Dwell Data separately            IndSmaller = Data(a).LongDwellLocation < CurrentBinEnd; %index of all the points smaller than upper limit            IndLarger  = Data(a).LongDwellLocation > CurrentBinStart; %index of all the points largert than lower limit             IndexKeep  = logical(IndLarger.*IndSmaller); %the index of the dwells that belong to the current bin                        if ~isempty(IndexKeep)                CorrData(a).LongDwellLocation{b}  = Data(a).LongDwellLocation(IndexKeep); %record the data that belongs to the current bin                CorrData(a).LongDwellTime{b}      = Data(a).LongDwellTime(IndexKeep); %record the data that belongs to the current bin                CorrData(a).NextLongDwellTime{b}  = Data(a).NextLongDwellTime(IndexKeep); %record the data that belongs to the current bin                CorrData(a).DistanceSeparation{b} = Data(a).DistanceSeparation(IndexKeep); %record the data that belongs to the current bin                CorrData(a).TemporalSeparation{b} = Data(a).TemporalSeparation(IndexKeep); %record the data that belongs to the current bin            end        end    else        %there is no data for this atp concentration        RemoveIndex = [RemoveIndex a]; %this particular ATP concentration has no data, will be removed at the end    endend%--- Remove the Data structure components that contain no dataCorrData(RemoveIndex)='';%--- Ask the user where to save the Compiled DataSaveFile=[ResultsFolder '\' 'CompiledLongDwellCorrelationData.mat'];uisave({'Data', 'CorrData'}, SaveFile);